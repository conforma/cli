# Unified Rule Filtering System

## Overview
The Enterprise Contract CLI uses a unified rule filtering system that provides comprehensive filtering capabilities for both evaluation-time and reporting-time decisions. The system is designed to be extensible and composable, making it easy to add new filtering criteria.

## Architecture

### Core Components
- **`RuleSelector` interface**: Provides unified filtering logic for both evaluation and reporting
- **`RuleFilter` interface**: Defines the contract for package-level filters
- **`FilterFactory` interface**: Creates filters from source configuration
- **`UnifiedFilterFactory`**: Creates unified filters using the RuleSelector
- **`filterNamespaces()` function**: Applies multiple filters in sequence with AND logic

### Current Implementation
- **`UnifiedRuleSelector`**: Implements comprehensive filtering logic including pipeline intentions, includes/excludes, and volatile exclusions
- **`UnifiedRuleFilter`**: Package-level filter that uses the unified selector
- **`NamespaceFilter`**: Combines multiple filters using AND logic

## Interface Definitions

```go
// RuleSelector provides unified filtering logic for both evaluation-time and reporting-time decisions
type RuleSelector interface {
    // PackagesToEvaluate determines which packages should be evaluated
    PackagesToEvaluate(allRules map[string]rule.Info) []string

    // ShouldReport determines if a specific rule should be included in results
    ShouldReport(ruleID string, imageDigest string, effectiveTime time.Time) bool

    // ExplainExclusion provides human-readable explanation for why a rule/package is excluded
    ExplainExclusion(ruleID string) string

    // GetIncludedRules returns all rule IDs that should be included for a given package
    GetIncludedRules(packageName string) []string

    // SetAllRules sets the complete rule set for analysis
    SetAllRules(allRules map[string]rule.Info)
}

// RuleFilter decides whether an entire package (namespace) should be
// included in the evaluation set.
type RuleFilter interface {
    Include(pkg string, rules []rule.Info) bool
}

// FilterFactory builds a slice of filters for a given `ecc.Source`.
type FilterFactory interface {
    CreateFilters(source ecc.Source) []RuleFilter
}
```

## Current Implementation

### UnifiedFilterFactory
The unified factory creates filters using the RuleSelector:

```go
type UnifiedFilterFactory struct {
    selector RuleSelector
}

func NewUnifiedFilterFactory(selector RuleSelector) FilterFactory {
    return &UnifiedFilterFactory{
        selector: selector,
    }
}

func (f *UnifiedFilterFactory) CreateFilters(source ecc.Source) []RuleFilter {
    return []RuleFilter{NewUnifiedRuleFilter(f.selector)}
}
```

### UnifiedRuleFilter
Filters packages using the unified selector:

```go
type UnifiedRuleFilter struct {
    selector RuleSelector
}

func NewUnifiedRuleFilter(selector RuleSelector) RuleFilter {
    return &UnifiedRuleFilter{
        selector: selector,
    }
}

func (f *UnifiedRuleFilter) Include(pkg string, rules []rule.Info) bool {
    // Convert rules to the format expected by the selector
    allRules := make(map[string]rule.Info)
    for _, rule := range rules {
        allRules[rule.Code] = rule
    }

    // Use the selector to determine if package should be included
    includedPackages := f.selector.PackagesToEvaluate(allRules)
    for _, includedPkg := range includedPackages {
        if includedPkg == pkg {
            return true
        }
    }
    return false
}
```

### UnifiedRuleSelector
Implements comprehensive filtering logic:

```go
type UnifiedRuleSelector struct {
    config         *FilterConfig
    volatileConfig *VolatileConfig
    effectiveTime  time.Time
    imageContext   *ImageContext
    allRules       map[string]rule.Info
}

func NewUnifiedRuleSelector(source ecc.Source, policy ConfigProvider, imageContext *ImageContext) RuleSelector {
    // Creates a unified selector with all filtering capabilities:
    // - Pipeline intention filtering
    // - Include/exclude list filtering  
    // - Volatile exclusion filtering
    // - Effective time filtering
}
```

## Integration with Conftest Evaluator

### Filtering Process
The filtering is integrated into the `Evaluate` method in `conftest_evaluator.go`:

```go
func (c conftestEvaluator) Evaluate(ctx context.Context, target EvaluationTarget) ([]Outcome, error) {
    // ... existing code ...
    
    // Filter namespaces using the new unified filtering system
    filterFactory := NewUnifiedFilterFactory(c.ruleSelector)
    filters := filterFactory.CreateFilters(c.source)
    filteredNamespaces := filterNamespaces(allRules, filters...)
    
    // ... rest of evaluation ...
}
```

## Helper Functions

### extractStringArrayFromRuleData
Extracts a string array from ruleData for a given key, handling both single string values and arrays:

```go
func extractStringArrayFromRuleData(source ecc.Source, key string) []string {
    var result []string
    if source.RuleData == nil {
        return result
    }

    var ruleDataMap map[string]interface{}
    if err := json.Unmarshal(source.RuleData.Raw, &ruleDataMap); err != nil {
        log.Debugf("Failed to parse ruleData: %v", err)
        return result
    }

    if values, ok := ruleDataMap[key]; ok {
        switch v := values.(type) {
        case []interface{}:
            for _, item := range v {
                if vStr, ok := item.(string); ok {
                    result = append(result, vStr)
                }
            }
        case string:
            result = append(result, v)
        }
    }

    return result
}
```

## File Organization

The unified filtering system is organized in the following files:

- `internal/evaluator/conftest_evaluator.go`: Main evaluator logic and the `Evaluate` method
- `internal/evaluator/filters.go`: Core filtering interfaces and helper functions:
  - `RuleFilter` interface
  - `FilterFactory` interface
  - `NamespaceFilter` implementation
  - `filterNamespaces()` function
  - Helper functions for extracting configuration
- `internal/evaluator/unified_filter.go`: Unified filtering implementation:
  - `UnifiedFilterFactory` for creating unified filters
  - `UnifiedRuleFilter` implementation
- `internal/evaluator/rule_selector.go`: RuleSelector interface and implementation:
  - `RuleSelector` interface
  - `UnifiedRuleSelector` implementation with comprehensive filtering logic

## Best Practices

### 1. Follow the Existing Pattern
- Use the same error handling approach as existing filters
- Include appropriate debug logging with `log.Debugf`
- Handle edge cases (nil values, wrong types, empty arrays)

### 2. Filter Behavior
- **No configuration**: Decide whether to return all packages or none
- **Empty array**: Decide whether to return no packages or all packages
- **Invalid types**: Gracefully handle non-string values

### 3. Performance
- Keep filtering logic efficient for large rule sets
- Consider early termination when possible
- Use appropriate data structures for lookups

### 4. Documentation
- Add clear comments explaining the filter's purpose
- Document the expected format of ruleData
- Include examples in comments

## Integration Points

### Policy Configuration
Add your field to the policy configuration:

```yaml
sources:
  - policy:
      - oci::quay.io/enterprise-contract/ec-release-policy:latest
    data:
      - git::https://github.com/conforma/policy//example/data
    ruleData:
      your_field_name: ["value1", "value2"]
```

### Rule Metadata
Update Rego rule metadata extraction in `internal/opa/rule/rule.go` if needed.

### Documentation
Update user documentation to explain the new filtering capability.

## Testing Considerations
- Test with various ruleData configurations
- Test edge cases (nil, empty, invalid types)
- Test performance with large rule sets
- Test integration with other filters
- Test the AND logic when combining multiple filters

## Migration from Old System
The old filtering system has been completely replaced with the new unified filtering architecture. The new system provides:

1. **Unified Logic**: Single `RuleSelector` interface handles all filtering decisions
2. **Better Performance**: More efficient filtering algorithms
3. **Enhanced Capabilities**: Support for volatile exclusions and effective time filtering
4. **Improved Maintainability**: Cleaner separation of concerns and better testability

## Recent Fix: Filtering Leak Prevention

### Problem
When filtering resulted in an empty list of namespaces, the conftest runner was still configured with `AllNamespaces=true`, which would evaluate ALL namespaces regardless of filtering.

### Solution
Simplified the namespace configuration logic to prevent the leak by always setting `AllNamespaces=false`:

```go
// Determine which namespaces to use
namespaceToUse := c.namespace

// If we have filtered namespaces from the filtering system, use those
if len(filteredNamespaces) > 0 {
    namespacesToUse = filteredNamespaces
}

// Always set AllNamespaces to false to prevent bypassing filtering
r = &conftestRunner{
    runner.TestRunner{
        // ... other fields ...
        AllNamespaces: false, // Always false to prevent bypassing filtering
    },
}
```

This extensible design makes it easy to add new filtering criteria without modifying existing code, following the Open/Closed Principle. 