# Pluggable Rule Filtering System

## Overview
The Enterprise Contract CLI uses a flexible rule filtering system that allows you to filter Rego rules based on various criteria before evaluation. The system is designed to be extensible and composable, making it easy to add new filtering criteria.

## Architecture

### Core Components
- **`PolicyResolver` interface**: Provides comprehensive policy resolution capabilities for both pre and post-evaluation filtering
- **`PostEvaluationFilter` interface**: Handles post-evaluation filtering and result categorization
- **`UnifiedPostEvaluationFilter`**: Implements unified filtering logic using the same PolicyResolver
- **`RuleDiscoveryService`**: Centralized service for discovering and collecting rules from policy sources, eliminating code duplication

### Key Design Principles
1. **Separation of Concerns**: Rule discovery is separated from evaluation logic
2. **Reusability**: The RuleDiscoveryService can be used independently of the evaluator
3. **Consistency**: All rule discovery uses the same service, ensuring consistent behavior
4. **Maintainability**: Single source of truth for rule discovery logic

## Rule Discovery

### RuleDiscoveryService
The `RuleDiscoveryService` is responsible for:
- Discovering all available rules from policy sources
- Handling both annotated and non-annotated rules
- Providing comprehensive rule information for filtering
- Supporting work directory sharing with the evaluator

#### Key Methods
- `DiscoverRules()`: Basic rule discovery for annotated rules only
- `DiscoverRulesWithNonAnnotated()`: Comprehensive discovery including non-annotated rules
- `DiscoverRulesWithWorkDir()`: Discovery using a specific work directory (used by evaluator)
- `CombineRulesForFiltering()`: Combines annotated and non-annotated rules into a single PolicyRules map for filtering

### Integration with Evaluator
The `conftestEvaluator` now uses the `RuleDiscoveryService` instead of implementing its own rule discovery logic:
- Eliminates ~100 lines of duplicate code
- Ensures policies are downloaded to the same work directory
- Maintains all existing functionality including non-annotated rule handling
- Provides cleaner separation of concerns
- Moves rule combination logic to the service via `CombineRulesForFiltering()`

## Policy Resolution

### PolicyResolver Interface
The `PolicyResolver` interface provides comprehensive policy resolution capabilities:

```go
type PolicyResolver interface {
    // Resolve policies and return filtering information
    ResolvePolicies(ctx context.Context, target EvaluationTarget) (PolicyResolution, error)
    
    // Get include/exclude criteria for backward compatibility
    Includes() []string
    Excludes() []string
}
```

### PolicyResolution Result
The resolution process returns a `PolicyResolution` struct containing:
- **Included Rules**: Map of rule codes that should be included
- **Excluded Rules**: Map of rule codes that should be excluded  
- **Included Packages**: Map of package names that should be included
- **Excluded Packages**: Map of package names that should be excluded
- **Missing Includes**: Map of include criteria that don't match any rules
- **Explanations**: Detailed explanations for each decision

## Post-Evaluation Filtering

### PostEvaluationFilter Interface
The `PostEvaluationFilter` interface handles post-evaluation filtering and result categorization:

```go
type PostEvaluationFilter interface {
    // Filter and categorize evaluation results
    FilterResults(results []Outcome, policyResolution PolicyResolution) (FilteredResults, error)
}
```

### UnifiedPostEvaluationFilter
The `UnifiedPostEvaluationFilter` implements unified filtering logic using the same `PolicyResolver`:

- **Consistent Logic**: Uses the same policy resolution logic for both pre and post-evaluation
- **Comprehensive Filtering**: Handles all result types (warnings, failures, exceptions, skipped)
- **Missing Includes Handling**: Generates warnings for unmatched include criteria
- **Success Computation**: Properly handles success results based on policy expectations

## Usage Examples

### Basic Rule Discovery
```go
ruleDiscovery := NewRuleDiscoveryService()
rules, err := ruleDiscovery.DiscoverRules(ctx, policySources)
if err != nil {
    return err
}
```

### Comprehensive Rule Discovery (Evaluator Usage)
```go
ruleDiscovery := NewRuleDiscoveryService()
rules, nonAnnotatedRules, err := ruleDiscovery.DiscoverRulesWithWorkDir(ctx, policySources, workDir)
if err != nil {
    return err
}

// Combine rules for filtering
allRules := ruleDiscovery.CombineRulesForFiltering(rules, nonAnnotatedRules)
```

### Policy Resolution
```go
policyResolver := NewECPolicyResolver(evaluatorResolver, availableRules)
resolution, err := policyResolver.ResolvePolicies(ctx, target)
if err != nil {
    return err
}
```

### Post-Evaluation Filtering
```go
postFilter := NewUnifiedPostEvaluationFilter(policyResolver)
filteredResults, err := postFilter.FilterResults(results, resolution)
if err != nil {
    return err
}
```

## Benefits

1. **Eliminated Code Duplication**: Rule discovery logic is centralized in RuleDiscoveryService
2. **Improved Maintainability**: Single source of truth for rule discovery
3. **Enhanced Reusability**: RuleDiscoveryService can be used independently
4. **Better Separation of Concerns**: Clear boundaries between discovery and evaluation
5. **Consistent Behavior**: All rule discovery uses the same logic and error handling
6. **Cleaner Architecture**: Evaluator focuses on evaluation, service handles discovery

## Migration Notes

The refactoring maintains full backward compatibility:
- All existing functionality is preserved
- No changes to public APIs
- Tests continue to pass
- Performance characteristics maintained
- Error handling behavior unchanged